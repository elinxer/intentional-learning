# 一条SQL查询语句是如何执行的？

我们以一条简单的查询语句为例？

```mysql
mysql> select * from T where id = 10;
```

我们更多的时候是只看到这只是一条语句，返回一个结果，却不知道这条语句在MySQL内部的执行过程。

很高兴能接触到MySQL45讲这门课程让我受益良多，接下来我就跟着丁奇老师来学习MySQL的知识。



![](E:\gin\intentional-learning\learingMysql\mysql45\picture\mysql45-01-01.png)

<div align=center style="color:#888888;">MySQL逻辑架构图</div>
MySQL 可以分成Server层和存储引擎两大部分

- Server层包括连接器、查询缓存（mysql8已经删除）、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能，以及所有内置函数（如：日期、时间、数字、加密函数），所有跨存储引擎的功能都在这里实现比如：存储过程、触发器、视图等。

- 存储引擎层负责数据额存储和提取。其架构模式是插件式式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常见的式InnoDB，它从MySQL5.5.5版本开始成为默认存储引擎。

## 连接器

第一步，连接数据库第一个模块式连接器，连接器负责跟客户端建立连接、获取权限、维持和管理连接。

```mysql
mysql -h$ip -P$port -u$user -p
-- 如本地连接：
-- mysql -h127.0.0.1 -P3306 -uroot -p
```

> 不建议-p后面直接跟密码，防止密码泄露

连接命令中的**mysql**是客户端工具用来和服务端建立连接，在完成完经典的TCP握手之后连接器就会开始认证输入的用户名和密码。

- 如密码不正确就会收到”Access denied for user“ 的错误，客户端结束执行
- 如果用户名密码认证通过连接器就会到权限表中查找当前用户的拥有的权限，之后的权限验证都要依赖此时读到的权限。

这个就意味如果一个用户已经成功建立连接，即使管理员修改这个用户的权限，也不会影响本次连接的权限，修改权限完成后，需要重新连接才会生效。

连接完成后如果没有后续的动作连接就会处于空闲状态，可以使用`show processlist`命令查看连接，在Command列相似为"Sleep"的这一行表示当前连接空闲。

![](E:\gin\intentional-learning\learingMysql\mysql45\picture\mysql45-01-02.png)

如果时间太长没有进行操作，连接器就会自动断开，这个时间的参数是由wait_timeout控制的，默认值是8小时

```mysql
-- 查看 wait_timeout
show global variables like 'wait_timeout';
-- 修改 wait_timeout
set global wait_timeout=14400;
```

![](E:\gin\intentional-learning\learingMysql\mysql45\picture\mysql45-01-03.png)

如果连接被断开之后，客户端在发送请求就和收到一个 ”Lost connection to MySQL server during query"的错误，这时需要重连再执行请求。

### 长短连接

- 长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接
- 短连接则指每一次执行完成很少的几次查询就端口连接，下一次查询就要重新新建一个

建立连接的过程是比较复杂，所有我们在使用的过程中要尽量是用长连接。

但是全部使用长连接可能会导致MySQL占用内存涨的特别快，这时因为MySQL中在执行过程中使用的内存是管理在连接对象里面的，这些资源只有在断开连接的时间才会释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀到，从现象看就是MySQL异常重启了

解决长连接内存占用大的方案：

1. 定期断开长连接。使用一段时间，或者程序里面执行过一个大内存的查询后，端口连接，之后要查询再重连（定时断开/查询大数据断开）
2. 如果是MySQL5.7+，就可以在每次执行完成一个较大的操作后，通过执行mysql_reset_connection 来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建的状态。

> mysql_reset_connection 是mysql为各种编程语言提供的api（C语言api） 不是MySQL内置语句或者语句



## 查询缓存

连接建立完成之后，就可执行select语句了，执行逻辑来到的第二部：查询缓存

MySQL 拿到查询缓存请求后，会先到查询缓存看看，是否之前有执行过这条语句。因为之前执行过的语句会以key-value对的形式被缓存在内存中。key：语句，value：返回的数据。如果能够找到对应的语句key，那么value结果就直接返回给客户端。


























## 自问自答
1. 为什么所有跨存储引擎、内置函数要设计在Server层？
答：存储Server层与存储引擎对接的方式是以接口方式对接的，每一种引擎去实现Server层的接口，这样用户将不关心因引擎不同导致sql的写法不同，也使存储引擎变成一种插件式，这样更好扩展。这样就比较好理解所有跨存储引擎功能要放在Server层了，因为不同的表存储引擎可能不同所以调用的规则可能不同，如果式放在Server就能很好的解决这个问题，直接调用存储引擎接口就可以；而内置函数也是放在Server层也是比较合理的，存储引擎主要是负责数据的存储和提取，而不是处理数据的，如果在Server层做处理就能忽略数据表是什么引擎，因为数据引擎返回统一的数格式，只要加一个函数处理功能就能对所有数据进行处理。
2. 如果user1第一次连接上数据库执行`select * from T`,管理员修改权限user1的权限不能访问T表，user1重连执行`select * from T` 会返回结果吗？