# 类的加载机制

## 概述

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

与那些在编译时需要进行连接工作的语言不同，在Java语言里面类的**类的加载、连接、和初始化** 过程都是在程序运行期间完成，这种策略虽然会令类加载时增加一些性能开销，但会为Java应用程序提供高度灵活性，Java动态扩展的语言特性就是依赖与运行期间动态加载和动态连接这个特点实现的.

>例如：如果编写一个面向接口的应用程序，可以等到运行期间再指定实际的实现类；
>
>用户可以通过预定义或者自定义类加载器，让本地一个应用程序可以在运行期间去网络或者其他地方加载一个二进制流作为程序的代码的一部分，主要的应用与Applet、JSP、OSGi

## 类的加载时机

类被虚拟机加载到卸载，整个的生命周期是：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）七个阶段，其中验证、准备、解析这3个部分统称为连接。

![](E:\gin\intentional-learning\blog\images\jvm\blog03_jvm_01.png)

其中加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，而**解析**阶段则不一定，如有可能在初始化阶段之后再开始解析，这也是为了支持Java语言运行时绑定（动态绑定）。

### 初始化

**虚拟机在五种情况下必须对类进行初始化：**

1. 遇到**new、getstatic、putstatic或invokestatic**这四条字节码指令时，如果类没有初始化，这需要先触发其初始化

   > 场景：使用new关键字实例化对象、读取或者设置一个类的静态字段（除了final修饰、已在编译期间就把结果放到常量池的静态字段除外）和调用一个类的静态方法时

```java
package dddy.gin.deep_understanding_jvm.chapter07;

public class ClassInitializing01 {

    public static void main(String[] args) {
        //new 关键字
        NewInitialization newInit = new NewInitialization();
        //getstatic
        System.out.println(GetStatic.S);
        //putstatic
        PutStatic.S = "getStatic initialization";
        //invokestatic
        InvokeStatic.getTime();

    }

}

class NewInitialization{
    static {
        System.out.println("new initialization");
    }
}

class GetStatic{
    static String S = "GetStatic.class";

    static {
        System.out.println("getStatic.class initialization");
    }
}

class PutStatic{
    static String S;

    static {
        System.out.println("PutStatic.class initialization");
    }
}

class InvokeStatic{
    static long getTime(){
        return System.currentTimeMillis();
    }

    static {
        System.out.println("InvokeStatic.class initialization");
    }
}
```

返回结果为：

```
new initialization
getStatic.class initialization
GetStatic.class
PutStatic.class initialization
InvokeStatic.class initialization
```

2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发初始化

```java
package dddy.gin.deep_understanding_jvm.chapter07;

import java.lang.reflect.Constructor;

public class ClassInitializing02 {
    public static void main(String[] args) throws Exception {
        Class<?> c = ReflectPackage.class;
        Constructor constructor = c.getConstructor();
        constructor.newInstance();
    }
}

class ReflectPackage {
    public ReflectPackage() {
    }

    static {
        System.out.println("Initialize ReflectPackage.class");
    }
}
```

3. 初始化一个类时，如果其父类还未初始化，需要先触发其父类的初始化

```java
package dddy.gin.deep_understanding_jvm.chapter07;

public class ClassInitializing03 {
    public static void main(String[] args) {
        new SonClass();
    }
}

class SuperClass{
    static {
        System.out.println("SuperClass Initialization");
    }
}

class SonClass extends SuperClass{
    static {
        System.out.println("SonClass Initialization");
    }
}
```

4. 虚拟机优先初始化用户指定的主类（如main（）方法所在的类）

```java
package dddy.gin.deep_understanding_jvm.chapter07;

public class ClassInitializing04 {
    static {
        System.out.println("MainClass Initialization");
    }

    public static void main(String[] args) {
        new NotMainClass();
    }
}

class NotMainClass {
    static {
        System.out.println("NotMainClass Initialization");
    }
}
```

5. 当使用JDK1.7+的动态语言支持时，如果一个java.lang.invoke.MethodHandle势力最后的解析结果时REF_getStatic、REF_putStatic、或ERF_invokeStatic的方法句柄，并且这个列的方法没有初始化则需要先触发其初始

```java
package dddy.gin.deep_understanding_jvm.chapter07;

import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.lang.invoke.MethodType;

public class ClassInitializing05 {
    public static void main(String[] args) throws Throwable {
        MethodHandles.Lookup lookup = MethodHandles.lookup();
        MethodHandle handle;
        handle = lookup.findStatic(REFGetStatic.class, "getS", MethodType.methodType(String.class, String.class));
        handle.invoke("hello world");
    }
}

class REFGetStatic {
    public static String getS(String s) {
        return s;
    }
    
    static {
        System.out.println("REFGetStatic Initialization");
    }
}
```

只有对于上面5种情况才会触发类进行初始，这5种场景的行为称之为对一个类的主动引用。除此之外所有引用类的方式都不会触发初始。下面我们来举例说明何为被动引用。











































自问自答：

1. JDK1.7种的时什么MethodHandle？
2. 